#!/usr/bin/env python3

import random
import pwn
import sys

"""
Please send: seed:string\n
I'll then show you the compression benchmark results!
Note: Flag has format DrgnS{[A-Z]+}
"""

#len is 25
# DrgnS{}  - 7 so there are 18 characters in the middle

seed = 25632 
flag = b'DrgnS{ABCEFGHIJKLMNOPQRT}'
correct = b'DrgnS{xxxxxxxxxxxxxxxxxx}'

cshuf = bytearray(correct)
random.seed(seed)
random.shuffle(cshuf)
print('correct, shuffled', cshuf)
s = bytearray(flag)
random.seed(seed)
random.shuffle(s)


index = [flag.find(x) for x in s]
rindex = [s.find(x) for x in flag]

shuf = bytearray(s)

shuf = bytearray(b'a' * 25)
for i in range(0, len(shuf)):
    n = index[i]
    if n < 7 or n == 24:
        shuf[i] = flag[n]

# nc compresstheflag.hackable.software 1337

c = pwn.connect('compresstheflag.hackable.software', 1337)
#c = pwn.connect('localhost', 1337)
print(c.recvlines(3))

alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

triples = set()

for i in alpha:
    for j in alpha:
        for k in alpha:
            triple = i+j+k
            triples.add(triple)
triples = list(triples)

def decode(s):
    d = ''
    for i in rindex:
        d += chr(s[i])
    return d

print(decode(cshuf))
def fixed(i):
    if index[i] < 6 or index[i] == 24:
        return flag[index[i]]
    return None

def getscore(c):
    lines = c.recvlines(5)
    lines = [' '.join(str(x, 'ascii').strip().split()) for x in lines[0:4]]
    lines = [x.split() for x in lines]
    return [int(y) for x,y in lines]

ob = '{'
cb = '}'
# with 654
#data = '\n'.join([f'{seed}:ITDgSES{cb}GrSSSHC{ob}IIRnIUAI{x}' for x in triples])
#b                         KTDgYES{cb}LrXSSHY{ob}IAFnIAMFG
#                          ITDgSES{cb}GrSSSHC{ob}IIRnIUAIE

#                   AT{ob}MnYLFDHSGIgSFEXK{cb}YISrA
#data = '\n'.join([f'{seed}:{x[:2]}{ob}{x[2]}nCGIDHSEIgSRESM{cb}SISrU' for x in triples])
data = '\n'.join([f'{seed}:{x[:2]}{ob}{x[2]}n' for x in triples])

print(decode(bytearray(b'IT{AnCGIDHSEIgSRESM}SISrU????????')))
c.sendline(bytes(data, 'ascii'))

# DrgnS{THISISACRIIEIGUESS}

scores = []
for tri in triples:
    score = sum(getscore(c))
    #print (tri, score)
    scores += [(tri, score)]

scores = sorted(scores, key = lambda x: x[1])

best = scores[0][1]
print([x for x in scores if x[1] == best])



"""
while True:
    i = random.randint(0, len(flag) - 1)
    if fixed(i) != None:
        continue

    j = ord(random.choice(alpha))

    if fails > 5000:
        shuf[i] = j
        fails += 1
        if fails == 5010:
            fails = 0
        print('fail', decode(shuf))
        continue

    test = shuf[:]
    test[i] = j
    line = f'{seed}:{str(test, "ascii")}'
    c.sendline(line)

    lines = c.recvlines(5)
    lines = [' '.join(str(x, 'ascii').strip().split()) for x in lines[0:4]]
    lines = [x.split() for x in lines]
    lines = [int(y) for x,y in lines]

    score = sum([x < y for x,y in zip(lines, best)])

    if score > 1:
        best = lines 
        shuf = test
        fails = 0
        print(decode(shuf), best)
    else:
        fails = fails + 1
#        print(fails)


"""
"""
for i in range(0, 2):
    if index[i] < 6 or index[i] == 24:
        continue

    for ch in alpha:
        shuf[i] = ord(ch)
        line = bytes(f'{seed}:{shuf}\n', 'ascii')
        print(line)
        data += line

    c.send(data)

    m = 9999
    out = []
    for ch in alpha: 
        lines = c.recvlines(5)

        lines = [' '.join(str(x, 'ascii').strip().split()) for x in lines[0:4]]
        lines = [x.split() for x in lines]
        lines = [int(y) for x,y in lines]
        lines += [sum(lines), ch]

        print(lines)
        if lines[3] < m:
            got = ch
            m = lines[3]

    shuf[i] = ord(got)

    
print(shuf)
n = ''
for i in rindex:
    n += chr(shuf[i])
print(n)
#print(sorted(out, key = lambda x: -x[3]))
"""



